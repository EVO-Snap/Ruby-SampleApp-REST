# This software and documentation is subject to and made
# available only pursuant to the terms of an executed license
# agreement, and may be used only in accordance with the terms
# of said agreement. This software may not, in whole or in part,
# be copied, photocopied, reproduced, translated, or reduced to
# any electronic medium or machine-readable form without
# prior consent, in writing, from EVO Payments International, INC.
#
# Use, duplication or disclosure by the U.S. Government is subject
# to restrictions set forth in an executed license agreement
# and in subparagraph (c)(1) of the Commercial Computer
# Software-Restricted Rights Clause at FAR 52.227-19; subparagraph
# (c)(1)(ii) of the Rights in Technical Data and Computer Software
# clause at DFARS 252.227-7013, subparagraph (d) of the Commercial
# Computer Software--Licensing clause at NASA FAR supplement
# 16-52.227-86; or their equivalent.
#
# Information in this software is subject to change without notice
# and does not represent a commitment on the part of EVO Payments International.
#
# Sample Code is for reference Only and is intended to be used for educational
# purposes. It's the responsibility of the software company to properly
# integrate into thier solution code that best meets thier production needs.
#
# Copyright:: 2017 EVO Payments International - All Rights Reserved
# License:: Proprietary

require 'json'

# The Workflows module contains the three "workflows" run in this sample
# application;  each lays out the typical workflows of a Snap* application.
#
# This workflow shows how to handle transactions captured using your own
# software, as opposed to an external terminal.
module Workflows
  def self.host_capture(client) # rubocop:disable Metrics/MethodLength, Metrics/PerceivedComplexity, Style/CyclomaticComplexity
    # Get service information to see the avilable functions.

    service_response = EvoCWS_endpoint_svcinfo.get_service_info(client)
    test_assert(service_response.data['Success'] == true, client)

    return if service_response.data['BankcardServices'].empty?

    service_id_found = false
    workflow_id_found = false
    service_response.data['BankcardServices'].each do |service|
      next if service['ServiceId'] != client.workflow_id
      service_id_found = true
      client.workflow_id = service['ServiceId']
    end
    service_response.data['Workflows'].each do |workflow|
      next if workflow['WorkflowId'] != client.workflow_id
      workflow_id_found = true
    end

    return unless service_id_found && !client.workflow_id.empty?

    profiles_response =
      EvoCWS_endpoint_merchinfo.get_merchant_profiles(client, client.service_id)
    test_assert(profiles_response.data['Success'] == true, client)
    parsed_response = JSON.parse(profiles_response.body)
    merch_id = parsed_response[0]['id']

    if merch_id.nil?
      # Skip the service if there aren't any merchant profiles defined.
      p "\n\nFAILED: Need a merchant profile for the service id: "\
        + client.service_id
      return
    end

    # We only need to test one merchant profile.
    # profiles_response.data["Results"].each { |the_merchant_profile|
    #	client.merchant_profile_id = the_merchant_profile["id"];
    #	if (client.merchant_profile_id[0..7] != "Default") then break; end
    # Avoid selecting a "Default" profile, generated by SaveMerchant profile
    # in the basic testing.
    # Fallthrough is okay. It selects the most recently created profile.

    profile =
      EvoCWS_endpoint_merchinfo.merchant_profile_initialized?(
        client,
        client.merchant_profile_id
      )
    test_assert(profile.data['Success'] == true, client)

    ####################

    # AUTHORIZE:  Create an authorization for a payment for later capture:
    if RbConfig::UseWorkflow == true
      authorized_response = EvoCWS_endpoint_txn.authorize_encrypted(client, {})
    else
      authorized_response = EvoCWS_endpoint_txn.authorize(client, {})
    end
    test_assert(authorized_response.data['Success'] == true, client)
    test_assert(authorized_response.data['Status'] != 'Failure', client)

    # CAPTURE:  Capture a previously authorized payment:
    EvoCWS_endpoint_txn.capture(
      client,
      'DifferenceData' => {
        "\type" => 'BankcardCapture,http://schemas.evosnap.com/CWS/v2.0/Transactions/Bankcard',
        'Amount' => '10.00',
        'TransactionId' => authorized_response.data['TransactionId'],
        'TipAmount' => '0.00'
      }
    )

    # AUTHORIZE and CAPTURE:  Handle both operations simultaneously:
    if RbConfig::UseWorkflow == true
      captured_response =
        EvoCWS_endpoint_txn.authorize_and_capture_encrypted(client, {})
    else
      captured_response = EvoCWS_endpoint_txn.authorize_and_capture(client, {})
    end
    test_assert(captured_response.data['Success'] == true, client)
    test_assert(captured_response.data['Status'] != 'Failure', client)

    # RETURN BY ID:  Make a refund of an authorized and captured transaction:
    EvoCWS_endpoint_txn.return_by_id(
      client,
      'DifferenceData' => {
        'TransactionId' => captured_response.data['TransactionId']
      }
    )

    # RETURN UNLIKED:  Provide funds without linking to a previous transaction:
    if RbConfig::UseWorkflow == true
      EvoCWS_endpoint_txn.return_unlinked_encrypted(client, {})
    else
      EvoCWS_endpoint_txn.return_unlinked(client, {})
    end
  end
end
